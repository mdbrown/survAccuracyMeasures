#' get Risk estimates and standard errors, called from SurvRM

#'@param data data.frame of xi (surv time), di (event ind), and Y (marker)
#'@param measures character vector of measures wanted, can be a subset of c("AUC", "beta", "TPR", "FPR", "PPV", "NPV")
#'@param predict.time numeric prediction time to evaluate measures at
#'@param CalVar Logical, should standard errors be calculated?
#'@return a list consisting of 'est' with point estimates in order of 'measures' and 
#'        (if CalVar == TRUE), 'sd' with standard errors for estimates. 
 

getEstimates <- function(data, 
                       cutoff,  
                       measures,
                       predict.time,
                       CalVar)
{  
  
#  browser()
  
  N = nrow(data)
  data$vi = 1; data$wi = 1

  
  #junk = GetRTdata(data, predict.time)  ## data.RT and data are sorted by Y 
  ###
   
    ####
    ## Est.Sy

  
     data.s <- data[order(-data$xi),] #data sorted by stime

     fit<-coxph( Surv(data$xi,data$di) ~ data$Y, weight = data$wi)
     betahat<-fit$coef
  

     r.riskset <-data.s$wi/cumsum(exp(data.s$Y*betahat )*data.s$wi)
     Lambda0t  <- sum(r.riskset[(data.s$xi <= predict.time)&(data.s$di == 1)])
  
     linearY <- data$Y*betahat
     Sy <- exp(-Lambda0t*exp(linearY))
  
  
    ####


  ooo = order(data$Y)
  data.RT <- cbind(data$Y, Sy, data$wi)[ooo,] ### this used to be Y instead of linearY, but I dont think this should be true
  
  Fck <- sum.I(data.RT[,1], ">=", data.RT[,1], data.RT[,3])/sum(data.RT[,3]) 
  data.RT <- cbind(data.RT[,-c(3)],Fck) 
  
 ###

  RT.out    <- EstRTall(data.RT)
  
  
  
  AUC       <- RT.out[[4]]
  IDI       <- RT.out[[5]]
  ITPR      <- RT.out[[6]]
  IFPR      <- RT.out[[7]]
  
  RT.out    <- RT.out[[1]]
  

  
  if (!is.null(measures[measures!="AUC"])) {
    typey = measures[measures!="AUC"]; 
    typex = rep("cutoff", length(typey))
    vp = rep(cutoff, length(typey));
    
    RTvp.out <- numeric(length(vp)); 
    for (jj in 1:length(vp)) { 
      RTvp.out[jj]= EstRTvp(RT.out,vp[jj],typex[jj],typey[jj])
    }
  }
  
  
  
  est = c(betahat, AUC, RTvp.out )   
  
  if (CalVar)  {

    subdata = cbind(data[ooo,],data.RT[,c(2)], linearY[ooo])
    names(subdata)=c("times","status","y","vi","weights","Sy","linearY")
    jjunk = Est.Wexp(subdata,N,RT.out,predict.time,vp,typex,typey)
    Wexp = cbind(jjunk$Wexp.beta,jjunk$Wexp.AUC,jjunk$Wexp.vp)
    
    #browser()
    sd = sqrt(Est.Var.CCH.trueweights(N,Wexp,subdata,subdata$status)[[1]])	
    list(est = est,sd =sd) 		
  } else {list(est = est)}
}

